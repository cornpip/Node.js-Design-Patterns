## async
비동기에 들어온 시점부터는 빠른 놈이 임자.(= 비동기는 페이지가 없다.)  

(페이지는 이런 의미)  
1페이지 비동기가 2페이지 비동기를 실행한다면  
1페이지가 전부 실행된 후 2페이지를 실행하는게 아니라  
1페이지의 settimeout cb보다 빠르면 2페이지가 먼저 실행되겠지  

순차적 실행과 재귀는 다른 개념같다.  
재귀는 함수안에 함수안에 함수안에.... 이렇게 실행되는건데  
node에서는 비동기는 블로킹 작업이 완료된 후 진행되므로 재귀라 보기에는 이어지지 않는 듯?  

----

`fs.open`은 파일을 객체로 다룸  
`fs.writefile` = open-> write-> close 와 같다.  
`fs.readfile` = open-> read  

# exercise

병렬 queue 랑 비슷하게 하려는데 어렵다.  
기능별로 분리하자니까 인자가 계속 걸리고 cb도 대부분은 처음 함수에 넣어준거 넘기는대로 쓰는거 같은데 중간에 cb정의하면 이게 오히려 헷갈리게 만든다.  

cb 는 err처리함수이자 함수 실행 끝나고 비동기로 실행시킬 마지막 함수라 생각하고 설계할 수 있따.  

재귀느낌의 코딩의 경우 cb에 함수가 들어있어 반복할텐데 err가 아닌 곳에서 사용하면 재귀 꼬인다는거 주의하자.

함수 안에서 함수를 정의하는 이유는 클로저를 가져가려고 하는 것  

class안에서 함수1 안에 함수2에서 this는 함수1을 가리키는 듯 하다. 일단 웬만하면 class안에서 함수 안의 함수를 정의하진 말자.  

최종 실행함수는 심플하게 남게끔하자.  

queue에 task스택쌓는 패턴은 queue에 쌓이는 함수에 다이렉트로는 인자를 같이 못준다.  
그래서 예제에서는 함수 하나를 거쳐 return으로 함수를 제공하게 만들었다.  
또는 함수의 실행을 모아둔 인자가 필요없는 함수를 만들어 둘 수 있다.

(일단 4-4동작 최종파일은 recursive파일에 있는 js)
